#!/usr/bin/env ruby
# encoding: utf-8

$root_dir = `git rev-parse --show-toplevel`.chomp
$externals_file = "#{$root_dir}/.gitexternals"
$ignore_file = "#{$root_dir}/.gitignore"
$configurations = {}

def usage
  puts "Usage: git external add <repository-url> <path> [<branch>]"
  puts "   or: git external rm <path>"
  puts "   or: git external status"
  puts "   or: git external init [--] [<path>...]"
  puts "   or: git external update [--] [<path>...]"
  puts "   or: git external cmd '<command>'"
  puts "   or: git external list"
  puts "   or: git external heads"
end

def load_configuration
  if File.file? $externals_file
    lines = `git config -l -f #{$externals_file}`.split(/\n/)
    $configurations = {}
    lines.each do |line|
      if line =~ /^external\.([^$]+)\.([^=]+)=(.*)$/
        $configurations[$1.chomp] ||= {}
        $configurations[$1.chomp][$2.chomp] = $3.chomp
      end
    end
  end
end

def print_configuration
  $configurations.each do |name, config|
    puts name
    config.each do |key, value|
      puts "\t#{key}: #{value}"
    end
  end
end

def normalize_url(url)
  if url =~ /^\./
    origin_url = `git config --get remote.origin.url`.chomp

    # If url has no protocol...
    unless origin_url =~ /^\w+:\/\//
      if origin_url =~ /^([^:\/]+):([^:]+)/
        # ... then assume it's ssh
        origin_url = "ssh://#{$1}/#{$2}"
      end
    end

    require 'uri'
    uri = URI.parse URI.encode origin_url
    uri.path = File.expand_path(url, uri.path)
    uri.to_s
  else
    url
  end
end

# Check if a branch exists
def branch_exists(path, branch)
    branches = `cd #{path}; git branch`
    regex = Regexp.new('[\\n\\s\\*]+' + Regexp.escape(branch.to_s) + '\\n')
    result = ((branches =~ regex) ? true : false)
    return result
end

def init_external(url, path, branch='master')
  require 'fileutils'
  if File.directory? "#{path}/.git"
    puts "- Repository already exists"
  else
    FileUtils.makedirs File.dirname(path)
    url = normalize_url url
    system "git clone #{url} #{path}"

    # Create a local tracking branch if it doesn't exist already
    unless branch_exists(path, branch)
      puts "- Creating local tracking branch: #{branch} -> origin/#{branch}"
      system "cd #{path}; git branch checkout --track #{branch} origin/#{branch}"
    end

    # Check out the local branch
    puts "- Checkout local branch: #{branch}"
    system "cd #{path}; git checkout #{branch}"
  end
end

def update_external(url, path, branch='master')
  require 'fileutils'
  if File.directory? "#{path}/.git"
   `cd #{path}; git remote update; git pull origin #{branch}`
  end
end

def get_default_head(path)
  origin_head = `cd #{path}; git symbolic-ref refs/remotes/origin/HEAD`
  if origin_head =~ /refs\/remotes\/origin\/(.*)/
    $1
  else
    raise "#{path}: Can't determine default HEAD for origin remote"
  end
end

def execute(cmd)
  values = []
  IO.popen(cmd) do |f|
    tmp = f.gets
    values.push(tmp.gsub(/\r/, '').gsub(/\n/, '')) unless tmp.nil?
  end
  return $?.exitstatus, values
end

def command_status
  ok = 0
  broken = 0
  $configurations.each do |name, config|
    branch = config["branch"]
    url = config["url"]
    path = config["path"]

    # Figure out the short name of the current branch
    # This is equivalent to 'git symbolic-ref --short HEAD'
    # but the --short is only available in pretty recent versions of git
    headBranch = `cd #{path} && git symbolic-ref HEAD | sed \"s/refs\\/heads\\///g\"`.chomp
    
    gitBranchExit, gitBranch = execute("cd #{path} && git config \"branch.#{headBranch}.merge\" | sed \"s/refs\\/heads\\///g\"")
    gitRemoteExit, gitRemote = execute("cd #{path} && git config \"remote.$(git config \"branch.#{headBranch}.remote\").url\"");

    if gitBranchExit != 0 && gitRemoteExit != 0
      puts "  ✗ #{path}: exit code #{gitBranchExit}, #{gitRemoteExit}"
      broken += 1
    else
      if branch == gitBranch[0]
        if url == gitRemote[0]
          puts "  ✓ #{path}"
          ok += 1
        else
          puts "  ✗ #{path} -- expected url '#{url}' but was '#{gitRemote[0]}'"
          broken +=1
        end
      else
        puts "  ✗ #{path} -- expected branch '#{branch}' but was '#{gitBranch[0]}'"
        broken +=1
      end
    end
  end
  puts "#{broken > 0 ? "✗" : "✓"} » #{ok} ok • #{broken} broken"
end

def command_add(url, path, branch='master')
  command_rm(path)
  `git config -f #{$externals_file} --add external.#{path}.path #{path}`
  `git config -f #{$externals_file} --add external.#{path}.url #{url}`
  `git config -f #{$externals_file} --add external.#{path}.branch #{branch}`
  `echo "#{path}" >> #{$ignore_file}`
end

def command_rm(path)
  if File.file? $externals_file
    `git config -f #{$externals_file} --unset external.#{path}.path`
    `git config -f #{$externals_file} --unset external.#{path}.url`
    `git config -f #{$externals_file} --unset external.#{path}.branch`
    `git config -f #{$externals_file} --remove-section external.#{path} > /dev/null 2>&1`
    File.delete $externals_file if `wc -l #{$externals_file}`.chomp.to_i == 0
  end
  if File.file? $ignore_file
    # Remove entry from .gitignore file
    `perl -pi -e 's/\\Q#{path.gsub(/\//, '\/')}\\E\n//g' #{$ignore_file}`
  end
end

def command_list_default_heads
  $configurations.each do |name, config|
    puts "#{name}: #{get_default_head(config["path"])}"
  end  
end

def command_init
  $configurations.each do |name, config|
    puts name
    init_external config["url"], config["path"], config["branch"]
  end
end

def command_update
  $configurations.each do |name, config|
    update_external config["url"], config["path"], config["branch"]
  end
end

def command_cmd(cmd)
  $configurations.each do |name, config|
    path = config['path']
    system("echo #{path}; cd #{path}; #{cmd}")
  end
end

def command_list
  print_configuration
end

load_configuration

command=ARGV[0]

case command
when "status" then command_status
when "add" then command_add ARGV[1], ARGV[2], ARGV[3] || "master"
when "rm" then command_rm ARGV[1]
when "init" then command_init
when "update" then command_update
when "cmd" then command_cmd ARGV[1]
when "list" then command_list
when "heads" then command_list_default_heads
else usage
end

